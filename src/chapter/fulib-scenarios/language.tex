\section{Sprache}\label{sec:language}

Kern dieser Arbeit ist eine neue Programmiersprache für textuelle Beispielszenarien.
Diese trägt den Namen Scenario-Sprache.
Ziel der Scenario-Sprache ist es, verständlich für jeden zu sein, der Englisch spricht.
Um als Programmiersprache funktionsfähig zu sein, hat sie im Gegensatz zu Englisch eine feste und eingeschränkte grammatikalische Struktur.
Somit handelt es sich um eine Untermenge der Englischen Sprache.
Des Weiteren basiert die Scenario-Sprache auf dem Markdown-Format,
das es erlaubt, einfachen Text mit Überschriften, Fett- und Kursivschreibung, Bildern u.ä.\ zu versehen.
Markdown-Dateien können leicht in HTML umgewandelt werden.
Somit können in der Scenario-Sprache verfasste Dateien als Dokumentation verwendet werden.
Im Folgenden werden einige Grundlagen der Scenario-Sprache dargestellt und erklärt.

\subsection{Grundlagen}\label{subsec:basics}

In der Scenario-Sprache verfasster Quellcode wird in \code{.md}-Dateien abgelegt.
Diese beginnen stets mit einer Überschrift, welche in Markdown mit dem \mdcode{#}-Symbol beginnen.
Mit der Überschrift beginnt ein \emph{Scenario};
deren Text wird zu dessen Namen.
Eine Scenario-Datei kann mehrere Überschriften und damit mehrere Scenarios enthalten.

Nach einer Überschrift können ein oder mehrere Sätze und Unterüberschriften folgen;
diese Bilden den Rumpf des Scenarios.
Unterüberschriften sind an \mdcode{##} am Anfang einer Zeile zu erkennen und ermöglichen die Strukturierung von langen Scenarios.

Im Rumpf von Scenarios gibt es einige Möglichkeiten, Kommentare zu hinterlassen.
Mit \jcode{//} wird wie in anderen Programmiersprachen ein Zeilenkommentar begonnen,
der mit dem nächsten Zeilenumbruch endet.
Dieser ist sowohl nach Umwaldeln des Markdown in HTML sichtbar,
als auch im erzeugten Java-Quellcode vorhanden.
Text der in runden Klammern \code{(...)} steht ist ebenfalls im HTML sichtbar,
jedoch nicht im Java-Quellcode.
Zuletzt können mit \mdcode{<!-- ... -->} Kommentare eingebettet werden,
die weder im HTML sichtbar noch im Java-Code vorhanden sind.

\subsection{Einfache Sätze und Ausdrücke}\label{subsec:simple-sentences-and-expressions}

Sätze bilden den Inhalt eines Scenarios und definieren dessen Ablauf.
Die Scenario-Sprache definiert eine Vielzahl von Sätzen,
die sich sowohl in ihrer Funktionalität ergänzen,
als auch syntaktische Alternativen mit gleicher Semantik füreinander darstellen.

Die einfachste Art von Satz ist der \code{Is}-Satz.
Dieser ermöglicht es, ein Objekt zu definieren und diesem Name und Typ zuzuweisen.
Ein Beispiel dafür ist

\code{Kassel is a City.}

Dabei ist \code{Kassel} der Name des Objekts,
und \code{City} dessen Typ.
\code{is} und \code{a} sind Schlüsselwörter.
Die äquivalente Java-Anweisung ist

\jcode{City kassel = new City();}

Zu beachten ist hier, dass die Klasse \code{City} nicht vorher deklariert werden muss.
Durch Verwenden des Namens wird diese automatisch angelegt.
Es gibt in der Scenario-Sprache keine Syntax für das manuelle Definieren von Klassen.

Ein weiterer einfacher Satz ist der \code{Has}-Satz.
Damit können Attribute von bereits bestehenden Objekten einen Wert zugewiesen bekommen.
Ein Beispiel dafür ist folgendes:

\code{Kassel has postcode 34117.}

Dabei ist \code{Kassel} der Name des Zielobjekts, in diesem Fall jenes, welches zuvor mit dem \code{Is}-Satz angelegt wurde.
\code{postcode} ist der Name des Attributs; \code{34117} der zuzuweisende Wert.
Aus diesem Satz wird der folgende Java-Code:

\jcode{kassel.setPostcode(34117)}

Wieder ist zu beachten, dass das Attribute \code{postcode} bzw.\ der Setter \code{setPostcode} nicht im Vorhinein deklariert wurde;
dieses wurde durch die Verwendung automatisch angelegt.
Durch den Ausdruck \code{34117} konnte ermittelt werden, dass der Typ dieses Attributes \code{int} sein muss.
Wäre der Wert stattdessen \code{D-34117}, was von der Scenario-Sprache als Zeichenkette verstanden wird,
hätte das Attribut den Typ \code{String} erhalten und der entsprechende Java-Code wäre \jcode{kassel.setPostcode("D-34117")}.

Da das Definieren von Objekten und die Zuweisung von Attributen sehr häufig in Kombination geschieht, bietet die Scenario-Sprache eine alternativ Satzart an, die beides gleichzeitig durchführt.
Diese Sätze heißen \code{There}-Sätze.
Die obigen Beispiele lassen sich mit einem There-Satz verkürzen:

\code{There is the City Kassel with postcode 34117.}

Hierbei sind die Schlüsselwörter \code{There is the} der Ersatz für \code{is},
während \code{has} durch \code{with} ersetzt wurde.
Der Java-Code ist äquivalent zu den beiden zuvor gezeigten Zeilen.

Bei erneuter Betrachtung des Java-Codes fällt auf, dass das Wort \code{Kassel} darin nur als Variablenname, jedoch nicht als Wert vorkommt.
Somit ist der Name der Stadt zur Laufzeit nicht zu ermitteln;
dies ist bei der Modellierung von Objektstrukturen i.d.R.\ unpraktisch.
Aus diesem Grund bieten \code{There}-Sätze eine Möglichkeit, eine Zeichenkette sowohl als Attributwert als auch als Variablennamen zu verwenden:

\code{There is a City with name Kassel and with postcode 34117.}

Hier ist zu sehen, dass in einem \code{There}-Satz mehrere Attributzuweisungen mit \code{with} möglich sind, indem sie durch \code{and} getrennt werden\footnote{
Alternativ können diese auch durch \code{,} (Komma) und \code{, and} (And mit Oxford-Komma) getrennt werden, da dies bei mehr als zwei \code{with} die Lesbarkeit erhöht.
}.
Das ansonsten unbenannte Objekt bezieht seinen Namen aus der ersten Attributzuweisung,
heißt also wieder \code{kassel}.
Der entsprechende Java-Code ist wie folgt:

\jcode{City kassel = new City();}\\
\jcode{kassel.setName("Kassel");}\\
\jcode{kassel.setPostcode(34117);}

Als nächstes soll die \code{City}-Klasse eine Assoziation erhalten.
Dafür wird zunächst ein anderes Objekt, hier \code{germany}, und eine andere Klasse, hier \code{Country}, benötigt.
Eine Assoziation von \code{kassel} zu \code{germany} kann nun wie ein Attribut angelegt werden.

\code{There is a country with name Germany.}\\
\code{Kassel has country Germany.}

Der entsprechende Java-Code ist:

\jcode{Country germany = new Country();}\\
\jcode{germany.setName("Germany");}\\
\jcode{kassel.setCountry(germany);}

Nun ist \code{country} eine \emph{unidirektionale} Zu-1-Assoziation von \code{City} zu \code{Country}.
Um diese bidirektional zu machen, muss der Name sowie die Kardinalität der Rückrichtung angegeben werden:

\code{Kassel has country and is one of the cities of Germany.}

Dabei ist \code{cities} der Name der Rückrichtung.
Die zugehörige Java-Zeile ist wie zuvor \jcode{kassel.setCountry(germany);}.
Offensichtlich ist der Name der Rückrichtung nicht in dieser vertreten.
Lediglich anhand des Quellcodes der \code{City}- bzw. \code{Country}-Klassen lässt sich dieser Zusammenhang erschließen.
\code{one of} gibt an, dass es sich dabei um eine Zu-n-Assoziation handelt;
durch dessen Entfernen kann auch die Rückrichtung zu-1 gemacht werden.
Dies ist aber in diesem Beispiel unerwünscht, da ein Land mehr als eine Stadt haben kann.

Alternativ kann die Assoziation auch ausgehend vom \code{Germany}-Objekt definiert werden:

\code{Germany has cities and is the country of Kassel and Berlin.}

Wichtig ist dabei, dass mehrere Zielobjekte angegeben werden (\code{Kassel} und \code{Berlin}, davon ausgehend dass \code{Berlin} analog zu \code{Kassel} definiert wurde).
Andernfalls würde aus \code{cities} trotz der Pluralform eine Zu-1-Assoziation werden.

\subsection{Test-Sätze und Diagramme}\label{subsec:test-sentences-and-diagrams}

Während die erzeugten Klassen Teil zum Programmquellcode gehören,
werden aus den Sätzen eines Scenarios Tests generiert.
Genauer wird aus jeder Scenario-Datei eine Testklasse,
und aus jedem Scenario wird eine Testmethode.
Mit Ausnahme von Sätzen, die zu Aufrufen gehören (siehe Unterabschnitt~\ref{subsec:methods}),
werden aus jedem Satz eine oder mehrere Anweisungen im Rumpf dieser Testmethode.

Damit Tests aussagekräftig sind, müssen sie die Ergebnisse der durchgeführten Aktionen überprüfen.
Dazu dienen in Java Assertions, welche sowohl von der Sprache als Schlüsselwort als auch von verschiedenen Test-Frameworks bereitgestellt werden.
Die Scenario-Sprache generiert Test-Code, der das Test-Framework JUnit~4~\cite{junit4} verwendet.
Sie bietet einige Sätze an, die auf Assertions abgebildet werden;
diese werden zusammengefasst als \code{Expect}-Sätze bezeichnet.
Im Folgenden werden diese nur in einer einfachen, statischen Form betrachtet.
Kapitel~\ref{ch:pattern-matching} führt eine erweiterte Form ein, die dynamische Erwartungen an Objektstrukturen mithilfe von Mustererkennung ermöglicht.

Ein Beispiel für einen \code{Expect}-Satz auf dem im vorherigen Unterabschnitt erstellten Objekt \code{kassel} ist:

\code{We expect that Kassel has postcode 34117.}

Dieser Satz fragt den Wert des \code{postcode}-Attributs des \code{kassel}-Objekts ab, und prüft ob dieser gleich 34117 ist.
Zu beachten ist hierbei die Analogie zu dem \code{has}-Satz, der in vorherigen Unterabschnitt das Attribut des \code{kassel}-Objekts gesetzt hat.
Der Satz erzeugt die folgende Java-Anweisung:

\jcode{assertEquals(34117, kassel.getPostcode())}

Der gleiche Java-Code wird generiert, wenn man den Satz umstellt:

\code{We expect that postcode of Kassel is 34117.}

Dabei ist \code{of} ein Schlüsselwort, mit dem der Wert eines Attributs erhalten werden kann.
Das Schlüsselwort \code{is} dient hier als binärer Operator der Gleichheit.
Würde man \code{34117} und \code{postcode of Kassel} vertauschen, würde der resultierende Satz die gleiche Bedeutung haben,
mit dem Unterschied dass Erwartungs- und tatsächlicher Wert der Assertion getauscht wären.
Neben \code{is} existieren weitere Operatoren zum Vergleichen von Werten;
diese werden in Unterabschnitt~\ref{subsec:control-structures} näher erläutert.

Die Scenario-Sprache bietet neben automatischen Tests auch die Möglichkeit, Objektstrukturen zu visualisieren.
Diese können sowohl der Verständlichkeit dienen als auch für die Dokumentation verwendet werden.
Dafür kommen Diagrammsätze zum Einsatz, die die Markdown-Syntax für Bilder (\mdcode{![Beschreibung](dateiname.png)}) verwenden und daher keine englischen Sätze sind.
Als Beschreibung dienen ein oder mehrere Objekte, die mit ihren über Assoziationen erreichbaren Nachbarn in einem Objektdiagramm dargestellt werden.
Dafür wird die FulibTools\cite{fulibTools}-Bibliothek verwendet.
Diese kann gegeben einige Startobjekte einen Objektgraphen bilden, diesen übersichtlich anordnen und als PNG-Bild oder Vektorgrafik zeichnen.
Um die zuvor definierten und verknüpften Objekte darzustellen, kann der folgende Diagramm-Satz verwendet werden:

\mdcode{![Germany](germany.png)}

Dies entspricht dem Aufruf zur Verwendung von FulibTools:

\jcode{FulibTools.objectDiagrams().dumpPng("germany.png", germany);}

Führt man das Scenario aus, wird die Datei \code{germany.png} erstellt.
Abbildung~\ref{fig:germany.png} zeigt das Objektdiagramm, das von dieser darstellt wird.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{chapter/fulib-scenarios/img/germany.png}
    \caption{Objektdiagramm von \code{germany}}
    \label{fig:germany.png}
\end{figure}

Neben der Dateiendung \code{.png} wird auch \code{.svg} für Vektorgrafiken unterstützt.
Diese werden zwar vergrößert besser dargestellt, eignen sich aber u.U.\ nicht für die Einbettung in Markdown.
Des Weiteren existieren diverse weitere Ausgabeformate, welche in der Dokumentation~\cite[Language.Sentences.Test Sentences.Diagram Sentences]{documentation} näher erläutert werden.

\subsection{Kontrollstrukturen}\label{subsec:control-structures}

Mit Scenarios lassen sich nicht nur statische Objektstrukturen erzeugen.
Es ist auch möglich, zur Laufzeit Entscheidungen zu fällen und davon abhängig unterschiedliche Ergebnisse zu erzeugen.
Dafür kommen \code{As}-Sätze zum Einsatz.
Diese entsprechen If-Anweisungen in Java, jedoch mit dem konzeptuellen Unterschied,
dass im Scenario vom Eintreten der Bedingung ausgegangen wird.
Daraus folgt die Verwendung des Schlüsselworts \code{As} statt \code{If},
sowohl die fehlende Syntax für \code{else}-Zweige\footnote{
Dies lässt sich durch Verwenden von zwei \code{As}-Sätzen mit gegensätzlichen Bedingungen umgehen.
}.

Das folgende Beispiel soll zur Illustration dieser Sätze dienen:

\code{As semester of Alice is less than 3, we add Maths to courses of Alice.}

Der \code{As}-Satz nimmt hier die Form \code{As <condition>, <sentence>.} an.
In der Bedingung wird der Wert des Attributs \code{semester} des Objekts \code{Alice} mit \code{3} verglichen, wobei \code{is less than} gleichzusetzen ist mit \code{<}.
Die Scenario-Sprache definiert Operatoren für Gleichheit (\code{is}), Ungleichheit (\code{is not}), Größer/Kleiner Als (\code{is greater/less than}) und Größer/Kleiner Gleich (\code{is greater/less equal}).

Ist die Bedingung wahr, wird der nachstehende Satz ausgeführt.
In diesem Beispiel ist dies ein \code{Add}-Satz, der Zahlen addieren und Elemente zu Listen bzw.\ Zu-n-Assoziationen hinzufügen kann.
In diesem Fall sind \code{Maths} und \code{Alice} im Vorhinein deklarierte Objekte;
\code{courses} ist eine Zu-n-Assoziation von der Klasse von \code{Alice} zu der Klasse von \code{Maths}.

Der zum obigen Beispiel gehörende Java-Code ist:

\jcode|if (alice.getSemester() < 3) {|\\
\jcode|    alice.withCourses(maths);|\\
\jcode|}|

Um mehrere Sätze im Rumpf der If-Anweisung zu erhalten, können mehrere Sätze hinter dem \code{As}-Satz durch \code{and} getrennt werden:

\code{As Alice has done Maths, we add 6 to credits of Alice and we remove 3 from motivation of Alice.}

\jcode|if (alice.getDone().contains(maths)) {|\\
\jcode|   alice.setCredits(alice.getCredits() + 6);|\\
\jcode|   alice.setMotivation(alice.getMotivation() - 3);|\\
\jcode|}|

Die zweite Art von Kontrollstruktur in der Scenario-Sprache ist der \code{Take}-Satz, der auf \code{for}-Schleifen in Java abgebildet wird.
Dieser nimmt die Form \code{We take a <name> from <expr> and <sentence...>} an, wobei \code{<name>} den Namen der Schleifenvariable, \code{<expr>} die zu durchlaufende Liste und \code{<sentence...>} den Schleifenrumpf bilden.
Im folgenden Beispiel ist diese Form ersichtlich:

\code{We take a student from students of uni and we add 1 to semester of student.}

Übersetzt in Java-Code ergibt sich die \code{for}-Schleife:

\jcode|for (Student student : uni.getStudents()) {|\\
\jcode|    student.setSemester(student.getSemester() + 1);|\\
\jcode|}|

Wichtig bei der Verwendung von \code{take} ist, dass der Ausdruck nach \code{from} einen \emph{Listentyp} hat.
Diese entsprechen in Java dem Typ \jcode{java.util.List<T>}, wobei \code{T} der Elementtyp ist.
Der Getter von Zu-n-Assoziationen hat automatisch einen Listentyp mit der Zielklasse als Elementtyp.

Es ist jedoch auch möglich, Listenausdrücke zu verwenden.
Diese bestehen in der einfachsten Form aus anderen Ausdrücken, die durch Komma oder \code{and} getrennt sind.
Beispiele dafür sind \code{1, 2, 3}, \code{Alice, Bob and Charlie} und \code{'left' and 'right'}.
In Java werden daraus Ausdrücke wie \code{Arrays.asList(1, 2, 3)} vom Typ \code{List<Integer>}.

Diese Listen lassen sich beispielsweise mit \code{write}-Sätzen in einer Variable speichern:

\code{We write Alice, Bob and Charlie into students.}

Daraus entsteht der folgende Java-Code:

\jcode{List<Student> students = new ArrayList<>(Arrays.asList(alice, bob, charlie));}

Zu beachten ist hier die Verwendung von \code{ArrayList};
durch diese können der Liste Elemente hinzugefügt oder entfernt werden.
Dies ist mit den \code{add}- und \code{remove}-Schlüsselwörtern möglich:

\code{We add David to students.}\\
\code{We remove Bob and Charlie from students.}

\jcode{students.add(david);}\\
\jcode{students.removeAll(bob, charlie);}

\todo{
Ranges?,
Vector Access?,
Contains conditional operator?,
Filter?,
}

\subsection{Methoden}\label{subsec:methods}

Bisher wurde sämtlicher Code von Sätzen in Testmethoden generiert.
Die Scenario-Sprache sieht es aber auch vor, Aktionen auf Objekten durchzuführen, welche in Methoden gekapselt werden.
Dafür soll neben dem Satz für Methodenaufrufe auch die Zuordnung über Subjekte betrachtet werden.

Ein Methodenaufruf in der Scenario-Sprache beginnt stets mit einem \code{call}-Satz.
Dieser nimmt die Form \code{We call <name> on <receiver> with <parameters...>} an, wobei sowohl Empfänger als auch Parameter optional sind.
Ein einfaches Beispiel ist folglich:

\code{We call init.}

Da sich \code{we} auf den Test bezieht und es keinen Empfänger gibt, ist das Testobjekt der Empfänger.
In der Testklasse wird eine Methode \code{init} angelegt, die an der Stelle des Satzes aufgerufen wird:

\jcode{init();}\\
\jcode{// ...}\\
\jcode|void init() {|\\
\jcode|}|

Nach dem \code{call}-Satz folgt der Rumpf.
Da es in der Scenario-Sprache keine geschweiften Klammern o.ä.\ gibt,
muss auf andere Weise zwischen den Sätzen unterschieden werden, die zum Rumpf gehören,
und jeden, die in der Testmethode auf den Aufruf folgen sollen.
Dafür dienen die Subjekte jedes Satzes.
Bei den meisten bisher kennengelernten Sätzen war dies \code{We}, welches sich auf die Testmethode bezieht.
Viele Sätze erlauben jedoch alternativ die Angabe eines Methodennamens wie \code{init} aus dem obigen Beispiel.
So kann festgelegt werden, dass sie zum Rumpf eines vorherigen Aufrufs gehören.
Die \code{init}-Methode kann also wie folgt gefüllt werden:

\code{We call init.}\\
\code{Init writes ... into students.}\\
\code{Init takes a student from students and init adds ... .}

Zu beachten ist, dass einige Sätze wie \code{expect} oder Diagramme nur in Tests erlaubt sind.
Bei anderen Sätzen wie \code{is} und \code{has} hat das Subjekt eine andere Bedeutung,
wodurch sie automatisch zum aktuell beschriebenen Rumpf oder Test gehören.
Zudam lassen sich Subjekte nicht mischen;
verwendet ein Satz ein anderes Subjekt als der vorherige, wird der vorherige Aufruf geschlossen.

\todo{
Empfänger,
Parameter,
Answer,
Stückweise Definition,
}

\todo{
The paper~\cite{explain}.
}
