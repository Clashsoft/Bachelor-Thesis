\chapter{Pattern Matching}\label{ch:pattern-matching}

\todo{
OCL (Object Constraint Language),
QVT (Query View Transform),
}

\section{Fulib-Tables}\label{sec:fulib-tables}

FulibTables\cite{fulibTables} ist eine Java-Bibliothek, mit der Objektstrukturen als Tabellen behandelt werden können.
Diese Tabellen dienen als Grundlage für einen Pattern Matcher, den die Bibliothek ebenfalls anbietet.
Im folgenden Abschnitt werden zunächst die Tabellen und deren Operationen anhang eines einfachen Beispiels vorgestellt.
Daraufhin werden die Möglichkeiten zum Pattern Matching betrachtet.

\subsection{Tabellen}\label{subsec:tables}

Um Tabellen nutzen zu können, wird zunächst ein Datenmodell benötigt.
Dazu soll beispielhaft das Modell von Universitäten und Studierenden verwendet werden.
Das entsprechende Klassendiagramm ist in Abbildung~\ref{fig:table-example-class-diagram} zu sehen.

\begin{figure}
    % TODO \includegraphics[width=\textwidth]{chapter/pattern-matching/img/class-diagram.pdf}
    \caption{Beispiel-Klassendiagramm zur Verwendung von FulibTables}
    \label{fig:table-example-class-diagram}
\end{figure}

Zunächst werden einige Objekte erstellt:

\begin{jcodeblock*}{breaklines}
    Student alice = new Student().setName("Alice").setCredits(200).setStudentID(1234);
    Student bob = new Student().setName("Bob").setCredits(100).setStudentID(5678);
    Student charlie = new Student().setName("Charlie").setCredits(300).setStudentID(1010);
    University uniKassel = new University().setName("Uni Kassel").setBachelorThreshold(180);
    uniKassel.withStudents(alice, bob, charlie);
\end{jcodeblock*}

Nun kann eine Tabelle angelegt werden.
Dabei wird der Name der Spalte sowie eine Liste von Objekten, die die Zeilen dieser Spalte bilden, angegeben.
Hier wird zunächst nur eine Zeile gebraucht.

\begin{jcodeblock}
    ObjectTable<University> uniTable = new ObjectTable<>("Uni", uniKassel);
\end{jcodeblock}

Diese lässt sich wie folgt darstellen:

\begin{tabular}{|c|}
    \hline
    \textbf{Uni} \\
    \hline
    Uni Kassel \\
    \hline
\end{tabular}

Auf dieser Tabelle lässt sich nun eine \emph{Erweiterung} durchführen, was mit der Methode \code{expandAll} erreicht wird.
Diese erwartet einen Spaltennamen sowie einen Lambda-Ausdruck,
der für jede Zeile eine Liste von Objekten zurückgibt, die die Zeilen der neuen Spalte bilden.
Dies wird anhand des Beispiels deutlich:

\begin{jcodeblock*}{breaklines}
    ObjectTable<Student> students = uniTable.expandAll("Students", University::getStudents);
\end{jcodeblock*}

Die neue Tabelle lässt sich wie folgt darstellen:

\begin{tabular}{|c|c|}
    \hline
    \textbf{Uni} & \textbf{Students} \\
    \hline
    Uni Kassel & Alice   \\
    Uni Kassel & Bob     \\
    Uni Kassel & Charlie \\
    \hline
\end{tabular}

Die \code{expandAll}-Methode ist geeignet für Zu-N-Assoziationen.
Für Attribute kommt die einfachere \code{expand}-Methode zum Einsatz.
Diese erhält die Anzahl der Zeilen.

\begin{jcodeblock*}{breaklines}
    Table<Integer> studentID = students.expand("Student ID", Student::getStudentID);
\end{jcodeblock*}

\begin{tabular}{|c|c|c|}
    \hline
    \textbf{Uni} & \textbf{Students} & \textbf{Student ID} \\
    \hline
    Uni Kassel & Alice   & 1234 \\
    Uni Kassel & Bob     & 5678 \\
    Uni Kassel & Charlie & 1010 \\
    \hline
\end{tabular}

Um eine Spalte zu entfernen, bieten Tabellen die Operationen \code{selectColumns} und \code{dropColumns} an.
Der folgende Code zeigt, wie diese verwendet werden können, um die Spalte \code{Student ID} zu löschen.
Ergebnis ist die zuvor gezeigte Tabelle.

\begin{jcodeblock}
    students.dropColumns("Student ID");
    // oder:
    students.selectColumns("Uni", "Students");
\end{jcodeblock}

U.U.\ ist der Name des zu erweiternden Attributs nicht bekannt.
Dafür wurde als Teil dieser Arbeit eine alternative \code{expandAll}-Operation entwickelt.
Diese bekommt keinen Lambda-Ausdruck übergeben, sondern ermittelt die existierenden Attribute und Assoziationen der Objekte zur Laufzeit mittels Reflection.

\begin{jcodeblock}
    Table<?> studentAttributes = students.expandAll("Student Attributes");
\end{jcodeblock}

Dabei wird aus jedem Attributswert jedes Student-Objekts eine neue Zeile.
Zu-N-Assoziationen und mehrwertige Attribute (Listen) werden dabei abgeflacht.

\begin{tabular}{|c|c|c|}
    \hline
    \textbf{Uni} & \textbf{Students} & \textbf{Student Attributes} \\
    \hline
    Uni Kassel & Alice   & ``Alice'' \\
    Uni Kassel & Alice   & 200  \\
    Uni Kassel & Alice   & 1234  \\
    Uni Kassel & Alice   & Uni Kassel  \\
    Uni Kassel & Bob     & ``Bob'' \\
    Uni Kassel & Bob     & 100  \\
    Uni Kassel & Bob     & 5678  \\
    Uni Kassel & Bob     & Uni Kassel  \\
    Uni Kassel & Charlie & ``Charlie'' \\
    Uni Kassel & Charlie & 300  \\
    Uni Kassel & Charlie & 1010  \\
    Uni Kassel & Charlie & Uni Kassel  \\
    \hline
\end{tabular}

Die Zeilen einer Spalte können nun nach bestimmten Eigenschaften durchsucht werden.
Diese Operation nennt sich \code{filter} und verwendet ebenfalls einen Lambda-Ausdruck,
der angibt, welche Zeilen entfernt und welche behalten werden sollen.
In diesem Beispiel wird unter allen Attributen nach ganzen, maximal dreistelligen Zahlen gesucht.

\begin{jcodeblock}
    studentAttributes.filter(it -> it instanceof Integer && (Integer) it <= 999);
\end{jcodeblock}

Dies ergibt die Anzahl der Credits, ohne dass der Name des Attributs angegeben werden musste:

\begin{tabular}{|c|c|c|}
    \hline
    \textbf{Uni} & \textbf{Students} & \textbf{Student Attributes} \\
    \hline
    Uni Kassel & Alice   & 200 \\
    Uni Kassel & Bob     & 100 \\
    Uni Kassel & Charlie & 300 \\
    \hline
\end{tabular}

Alternativ lassen sich \code{filter}-Operationen auch auf allen Spalten anwenden.
Dafür wird zunächst eine Spalte für das \code{bachelorThreshold}-Attribut von \code{University} benötigt:

\begin{jcodeblock}
    uniTable.expand("Threshold", University::getBachelorThreshold);
\end{jcodeblock}

\begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Uni} & \textbf{Students} & \textbf{Student Attributes} & \textbf{Threshold} \\
    \hline
    Uni Kassel & Alice   & 200 & 180 \\
    Uni Kassel & Bob     & 100 & 180 \\
    Uni Kassel & Charlie & 300 & 180 \\
    \hline
\end{tabular}

Nun können mit der \code{filterRows}-Operation Zeilen ausgewählt werden, die eine Bedingung über alle Spalten erfüllen.
Dafür dient ein Lambda-Ausdruck, der für jede Zeile eine Zuordnung von Spaltenname zu Wert in dieser Zeile enthält.
Dessen Ergebnis bestimmt, ob die Zeile behalten oder entfernt wird.

\begin{jcodeblock}
    students.filterRows(row -> {
        int credits = (int) row.get("Student Attributes");
        int threshold = (int) row.get("Threshold");
        return credits >= threshold;
    });
\end{jcodeblock}

In diesem Beispiel sorgt das dafür, dass die Zeile mit dem Studenten Bob entfernt wird.

\begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Uni} & \textbf{Students} & \textbf{Student Attributes} & \textbf{Threshold} \\
    \hline
    Uni Kassel & Alice   & 200 & 180 \\
    Uni Kassel & Charlie & 300 & 180 \\
    \hline
\end{tabular}

Aus dieser Tabelle lässt sich nun ein Ergebnis erzeugen, indem die Tabellenspalte \code{Students} in eine Liste konvertiert wird.

\begin{jcodeblock}
    System.out.println(students.toList() + " are ready to complete their Bachelor's");
    // Output: [Alice, Charlie] are ready to complete their Bachelor's
\end{jcodeblock}

\subsection{Patterns}\label{subsec:patterns}

Patterns sind ein Mechanismus von FulibTables, der die Suche nach Objekten mit bestimmten Eigenschaften in einer Objektstruktur erlaubt.
Die Bibliothek gibt dafür eine einfache API zum Konstruieren von Patterns vor.
Intern wird das Pattern Matching mit Tables realisiert,
die in ihren Operationen gleichmächtig mit Patterns sind.
Jedoch ist die Verwendung von Patterns übersichtlicher und leichter verständlich.
Des Weiteren lassen sich Pattern als Objekte modellieren,
während Tables nur mit einer Folge von Anweisungen bearbeitet werden.
Dadurch lassen sich Patterns deklarative gebrauchen, während Tables imperativ verwendet werden.

Ein Pattern besteht aus einer Menge von \emph{Pattern-Objekten} und Constraints auf diesen.
Pattern-Objekte dienen als Platzhalter für Objekte, nach denen gesucht wird,
während Constraints deren Beziehungen modellieren.

Es soll nun die oben mit Tables realisiert Suche nach Studierenden dmit Patterns realisert werden.
Dafür werden zunächst einige Pattern-Objekte benötigt.
Diese lassen sich mit einem \code{PatternBuilder} anlegen.

\begin{jcodeblock*}{breaklines}
    PatternBuilder builder = FulibTables.patternBuilder();

    PatternObject uniPO = builder.buildPatternObject("Uni");
    PatternObject thresholdPO = builder.buildPatternObject("Threshold");
    PatternObject studentsPO = builder.buildPatternObject("Students");
    PatternObject studentAttributesPO = builder.buildPatternObject("StudentAttributes");
\end{jcodeblock*}

Pattern-Objekte werden nicht nur für Objekte im Datenmodell (z.B.\ \code{uniPO} und \code{studentsPO}),
sondern auch für deren Attribute benötigt (\code{thresholdPO} und \code{studentAttributesPO}).
I.A.\ entspricht jedes Pattern-Objekt einer Spalte der Tabelle, die am Ende des Match-Vorgangs alle Ergebnisse enthält.

Nun müssen die Pattern-Objekte verbunden werden.
Dies geschieht unter Angabe der Attribut- bzw.\ Assoziationsnamen mit der \code{buildPatternLink}-Methode.

\begin{jcodeblock}
    builder.buildPatternLink(uniPO, "bachelorThreshold", thresholdPO);
    builder.buildPatternLink(uniPO, "uni", "students", studentsPO);
    builder.buildPatternLink(studentsPO, "*", studentAttributesPO);
\end{jcodeblock}

Zu beachten ist in der letzten Zeile der Name ``\code{*}''.
Dieser dient als Platzhalter für den unbekannten Attributsnamen.
Er bewirkt, dass \code{studentAttributesPO} alle Attribute von \code{studentsPO} matcht.
Diese Operation ist in Vorbereitung dieser Arbeit aufbauend auf dem zuvor genutzten \code{expandAll} entstanden.
Wie im vorherigen Beispiel soll dies eingeschränkt werden auf ganze Zahlen unter 1000.
Dafür kommt ein \emph{Attributs-Constraint} zum Einsatz, das wie folgt angelegt wird:

\begin{jcodeblock*}{breaklines}
    builder.buildAttributeConstraint(studentAttributesPO, it -> it instanceof Integer && (Integer) it <= 999);
\end{jcodeblock*}

Kern der Suche ist nun die Bedingung, dass die Credit-Anzahl größer als das von der Uni vorgegebene Minimum für die Bacheloranmeldung ist.
Analog zu \code{filterRows} bei Tables kommt dafür bei Patterns ein \emph{Match-Constraint} zum Einsatz,
das wie folgt deklariert wird:

\begin{jcodeblock}
    builder.buildMatchConstraint(row -> {
        int credits = (int) row.get("StudentAttributes");
        int threshold = (int) row.get("Threshold");
        return credits >= threshold;
    }, studentAttributesPO, thresholdPO);
\end{jcodeblock}

Der Lambda-Ausdruck entspricht hier exakt jenem, der mit \code{filterRows} gebraucht wurde.
Zu beachten ist jedoch hier die Angabe, dass die zu verwendenden Pattern-Objekte dahinter angegeben wurden.
Ohne diese Angabe könnten Match-Constraints immer erst als letzte aufgelöst werden,
was u.U.\ zu sehr großen Zwischenergebnissen führen kann.

Nun sind alle Pattern-Objekte und Constraints angelegt.
Mit \code{builder.getPattern()} lässt sich eine Objekt erhalten, dass all diese kapselt.
Das davon ausgehende Objektdiagramm ist in Abbildung~\ref{fig:pattern-diagram} dargestellt.

\begin{figure}
    % TODO \includegraphics[width=\textwidth]{chapter/pattern-matching/img/pattern-diagram.pdf}
    \caption{Objektdiagramm für das erstellte Pattern}
    \label{fig:pattern-diagram}
\end{figure}

Mit dem Pattern kann nun ein Matching durchgeführt werden.
Dafür wird zunächst ein \code{PatternMatcher} benötigt, der auch direkt aus dem \code{builder} angelegt werden kann.
Dem Matcher werden dann ein oder mehr \emph{Root-Objekte} und \emph{Root-Pattern-Objekte} zugewiesen.
Diese entsprechen den Objekten und Pattern-Objekten, bei denen die Suche begonnen wird.
Ferner werden daraus die Zeilen und Spalten der Tabelle, die intern als Datenstruktur dient.

\begin{jcodeblock}
    PatternMatcher matcher = builder.matcher();
    matcher.withRootPatternObjects(uniPO);
    matcher.withRootObjects(uniKassel);
\end{jcodeblock}

Die Methode \code{match()} führt nach Einrichten des Matchers den eigentlichen Match-Vorgang durch.
Daraufhin lassen sich die Ergebnisse anhand der Pattern-Objekte extrahieren:

\begin{jcodeblock}
    matcher.match();

    List<Student> bachelorReady = matcher.findAll(studentsPO);
    // = [Alice, Charlie]
\end{jcodeblock}

\todo{
Interne Tabellen beim Pattern Matching,
}

\section{Pattern Matching in der Scenario-Sprache}\label{sec:scenario-pattern-matching}

\todo{
We match,
Expectations,
Parallelen OCL/QVT,
}
