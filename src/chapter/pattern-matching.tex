\chapter{Pattern Matching}\label{ch:pattern-matching}

\todo{
OCL (Object Constraint Language),
QVT (Query View Transform),
}

\section{Fulib-Tables}\label{sec:fulib-tables}

FulibTables\cite{fulibTables} ist eine Java-Bibliothek, mit der Objektstrukturen als Tabellen behandelt werden können.
Diese Tabellen dienen als Grundlage für einen Pattern Matcher, den die Bibliothek ebenfalls anbietet.
Im folgenden Abschnitt werden zunächst die Tabellen und deren Operationen anhang eines einfachen Beispiels vorgestellt.
Daraufhin werden die Möglichkeiten zum Pattern Matching betrachtet.

\subsection{Tabellen}\label{subsec:tables}

Um Tabellen nutzen zu können, wird zunächst ein Datenmodell benötigt.
Dazu soll beispielhaft ein Modell von einem fiktiven Spiel für mehrere Spieler verwendet werden.
Jeder Spieler hat ein oder mehrere Häuser, die eine Zahl von Einheiten haben.
Ziel des Spiel ist es, in mindestens einem Haus eine bestimmte Anzahl von Einheiten zu erreichen.
Das entsprechende Klassendiagramm ist in Abbildung~\ref{fig:game-class-diagram} zu sehen.

\begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{chapter/pattern-matching/img/game-class-diagram.png}
    \caption{Beispiel-Klassendiagramm zur Verwendung von FulibTables}
    \label{fig:game-class-diagram}
\end{figure}

Es werden nun einige Beispielobjekte zu diesem Modell erstellt, die den Endzustand des Spiels beschreiben.

\begin{jcodeblock*}{breaklines}
    Game game = new Game().setWinScore(60);
    Player alice = new Player().setName("Alice").setGame(game);
    Player bob = new Player().setName("Bob").setGame(game);
    Player charlie = new Player().setName("Charlie").setGame(game);
    House a1 = new House().setId("a1").setUnits(30).setPlayer(alice);
    House a2 = new House().setId("a2").setUnits(20).setPlayer(alice);
    House b1 = new House().setId("b1").setUnits(40).setPlayer(bob);
    House c1 = new House().setId("c1").setUnits(60).setPlayer(charlie);
\end{jcodeblock*}

Das zugehörige Objektdiagramm ist in Abbildung~\ref{fig:game-object-diagram} zu sehen.

\begin{figure}
    \includegraphics[width=\textwidth]{chapter/pattern-matching/img/game-object-diagram.png}
    \caption{Beispiel-Objektdiagramm zur Verwendung von FulibTables}
    \label{fig:game-object-diagram}
\end{figure}

Nun kann eine Tabelle angelegt werden.
In FulibTables besteht jede Tabelle aus mindestens einer Spalte und null oder mehr Zeilen\footnote{Der Spaltenname zählt dabei nicht als Zeile.}.
Tabellen können \emph{erweitert} oder \emph{eingeschränkt} werden, wobei Spalten entstehen oder entfernt werden.
Beim Erweitern entstehen neue Tabellen-Instanzen,
die sich die Daten der ursprünglichen Tabelle teilen.
Jede Tabellen-Instanz hat eine Spalte, auf die sie \emph{zeigt}.
Operationen auf der Tabelle beziehen sich i.d.R.\ auf diese Spalte,
wirken sich aber durch das geteilte Datenmodell auf alle anderen Instanzen aus.
Zunächst wird nur eine einfache Tabelle mit einer Spalte und einer Zeile benötigt.
Dafür müssen der Name der ersten Spalte sowie eine Liste von Objekten, die die Zeilen dieser Spalte bilden, angegeben werden.
Hier wird zunächst nur eine Zeile gebraucht.

\begin{jcodeblock}
    ObjectTable<Game> games = new ObjectTable<>("Games", game);
\end{jcodeblock}

Diese lässt sich wie folgt darstellen:

\begin{tabular}{|c|}
    \hline
    \textbf{Games} \\
    \hline
    g \\
    \hline
\end{tabular}

Auf dieser Tabelle lässt sich nun eine Erweiterung durchführen, was mit der Methode \code{expand} erreicht wird.
Diese erwartet zuerst einen Namen für die neue Spalte, die sowohl der alten Tabelle hinzugefügt wird als auch Ziel der neuen Tabellen-Instanz ist.
Weiterhin wird eine Funktion in Form eines Lambda-Ausdrucks übergeben.
Dieser wird für jede Zeile der Tabelle aufgerufen.
Die Ergebnisse bilden dann die Zeilen der neuen Spalte.
Dies wird anhand des Beispiels deutlich:

\begin{jcodeblock*}{breaklines,escapeinside=||}
    Table<Integer> winScores = games.expand("Win Scores", Game::getWinScore|\footnotemark|);
\end{jcodeblock*}
\footnotetext{Bei diesem Ausdruck handelt es sich um eine Methodenreferenz, die zu dem Lambda-Ausdruck \jcode{game -> game.getWinScore()} äquivalent ist.}

Die neue Tabelle lässt sich wie folgt darstellen:

\begin{tabular}{|c|c|}
    \hline
    \textbf{Games} & \textbf{Win Scores} \\
    \hline
    g & 60 \\
    \hline
\end{tabular}

Die \code{expand}-Methode ist geeignet für Attribute und Zu-1-Assoziationen.
Für Zu-N-Assoziationen kommt die \code{expandAll}-Methode zum Einsatz.
Diese erwartet ebenfalls einen Spaltennamen und einen Lambda-Ausdruck,
allerdings muss letzterer eine Liste von Werten zurückgegeben.
Für jedes Element dieser Listen wird eine neue Zeile angelegt.

\begin{jcodeblock*}{breaklines}
    ObjectTable<Player> players = games.expandAll("Players", Game::getPlayers);
\end{jcodeblock*}

\begin{tabular}{|c|c|c|}
    \hline
    \textbf{Games} & \textbf{Win Scores} & \textbf{Players} \\
    \hline
    g & 60 & Alice   \\
    g & 60 & Bob     \\
    g & 60 & Charlie \\
    \hline
\end{tabular}

Um das Verhalten zu verdeutlichen, wird eine weitere \code{expandAll}-Operation auf der entstandenen Tabelle durchgeführt.
Da Alice zwei Häuser hat, wird ihre Zeile dupliziert.
Bei Bob und Charlie ist dies nicht der Fall.

\begin{jcodeblock*}{breaklines}
    ObjectTable<House> houses = players.expandAll("Houses", Player::getHouses);
\end{jcodeblock*}

\begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Games} & \textbf{Win Scores} & \textbf{Players} & \textbf{Houses} \\
    \hline
    g & 60 & Alice   & a1 \\
    g & 60 & Alice   & a2 \\
    g & 60 & Bob     & b1 \\
    g & 60 & Charlie & c1 \\
    \hline
\end{tabular}

U.U.\ ist der Name des zu erweiternden Attributs nicht bekannt.
Dafür wurde als Teil dieser Arbeit eine alternative \code{expandAll}-Operation entwickelt,
bei der dieser nicht angegeben werden muss.
Diese bekommt keinen Lambda-Ausdruck übergeben, sondern ermittelt die existierenden Attribute und Assoziationen der Objekte zur Laufzeit mittels Reflection.

\begin{jcodeblock}
    Table<?> houseAttributes = houses.expandAll("House Attributes");
\end{jcodeblock}

Dabei wird aus jedem Attributwert und jedem Assoziationsziel jedes Objekts der Spalte \code{Houses} eine neue Zeile.
Zu-N-Assoziationen und mehrwertige Attribute (Listen) werden dabei abgeflacht.

\begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Games} & \textbf{Win Scores} & \textbf{Players} & \textbf{Houses} & \textbf{House Attributes} \\
    \hline
    g & 60 & Alice   & a1 & a1      \\
    g & 60 & Alice   & a1 & Alice   \\
    g & 60 & Alice   & a1 & 30      \\
    g & 60 & Alice   & a2 & a2      \\
    g & 60 & Alice   & a2 & Alice   \\
    g & 60 & Alice   & a2 & 20      \\
    g & 60 & Bob     & b1 & b1      \\
    g & 60 & Bob     & b1 & Bob     \\
    g & 60 & Bob     & b1 & 40      \\
    g & 60 & Charlie & c1 & c1      \\
    g & 60 & Charlie & c1 & Charlie \\
    g & 60 & Charlie & c1 & 60      \\
    \hline
\end{tabular}

Die Zeilen einer Spalte können nun nach bestimmten Eigenschaften durchsucht werden.
Diese Operation nennt sich \code{filter} und verwendet ebenfalls einen Lambda-Ausdruck,
der angibt, welche Zeilen entfernt und welche behalten werden sollen.
In diesem Beispiel wird unter allen Attributen von Häusern nach ganzen Zahlen gesucht.

\begin{jcodeblock}
    houseAttributes.filter(it -> it instanceof Integer);
\end{jcodeblock}

Dies ergibt die Anzahl der Credits, ohne dass der Name des Attributs angegeben werden musste:

\begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Games} & \textbf{Win Scores} & \textbf{Players} & \textbf{Houses} & \textbf{House Attributes} \\
    \hline
    g & 60 & Alice   & a1 & 30      \\
    g & 60 & Alice   & a2 & 20      \\
    g & 60 & Bob     & b1 & 40      \\
    g & 60 & Charlie & c1 & 60      \\
    \hline
\end{tabular}

Alternativ kann auch eine Filterung über alle Spalten durchgeführt werden, wofür die \code{filterRows}-Operation eingesetzt wird.
Diese erhält einen Lambda-Ausdruck, der für jede Zeile alle Werte erhält.
Die Werte befinden sich in einer Zuordnung (\code{Map}), die einen Spaltennamen zu dem Wert in der Zeile dieser Spalte zuordnet.
Dessen Ergebnis bestimmt wie beim einfachen Filter, ob die Zeile behalten oder entfernt wird.

\begin{jcodeblock}
    houseAttributes.filterRows((Map<String, Object> row) -> {
        int winScore = (int) row.get("Win Scores");
        int units = (int) row.get("House Attributes");
        return units >= winScore;
    });
\end{jcodeblock}

In diesem Beispiel sorgt das dafür, dass alle Zeilen außer die mit dem Spieler Charlie entfernt werden.

\begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Games} & \textbf{Win Scores} & \textbf{Players} & \textbf{Houses} & \textbf{House Attributes} \\
    \hline
    g & 60 & Charlie & c1 & 60 \\
    \hline
\end{tabular}

Die Suche nach einem Gewinner ist nun abgeschlossen.
Aus der Tabelle lässt sich nun ein Ergebnis erzeugen, indem die Tabellenspalte \code{Players} in eine Liste konvertiert wird.

\begin{jcodeblock}
    System.out.println("the winner is: " + players.toList());
    // Output: the winner is: [Charlie]
\end{jcodeblock}

\subsection{Patterns}\label{subsec:patterns}

Patterns sind ein Mechanismus von FulibTables, der die Suche nach Objekten mit bestimmten Eigenschaften in einer Objektstruktur erlaubt.
Die Bibliothek gibt dafür eine einfache API zum Konstruieren von Patterns vor.
Intern wird das Pattern Matching mit Tables realisiert,
die in ihren Operationen gleichmächtig mit Patterns sind.
Jedoch ist die Verwendung von Patterns übersichtlicher und leichter verständlich.
Des Weiteren lassen sich Pattern als Objekte modellieren,
während Tables nur mit einer Folge von Anweisungen bearbeitet werden.
Dadurch lassen sich Patterns deklarative gebrauchen, während Tables imperativ verwendet werden.

Ein Pattern besteht aus einer Menge von \emph{Pattern-Objekten} und Constraints auf diesen.
Pattern-Objekte dienen als Platzhalter für Objekte, nach denen gesucht wird,
während Constraints deren Beziehungen modellieren.

Es soll nun die oben mit Tables realisiert Suche nach Studierenden dmit Patterns realisert werden.
Dafür werden zunächst einige Pattern-Objekte benötigt.
Diese lassen sich mit einem \code{PatternBuilder} anlegen.

\begin{jcodeblock*}{breaklines}
    PatternBuilder builder = FulibTables.patternBuilder();

    PatternObject uniPO = builder.buildPatternObject("Uni");
    PatternObject thresholdPO = builder.buildPatternObject("Threshold");
    PatternObject studentsPO = builder.buildPatternObject("Students");
    PatternObject studentAttributesPO = builder.buildPatternObject("StudentAttributes");
\end{jcodeblock*}

Pattern-Objekte werden nicht nur für Objekte im Datenmodell (z.B.\ \code{uniPO} und \code{studentsPO}),
sondern auch für deren Attribute benötigt (\code{thresholdPO} und \code{studentAttributesPO}).
I.A.\ entspricht jedes Pattern-Objekt einer Spalte der Tabelle, die am Ende des Match-Vorgangs alle Ergebnisse enthält.

Nun müssen die Pattern-Objekte verbunden werden.
Dies geschieht unter Angabe der Attribut- bzw.\ Assoziationsnamen mit der \code{buildPatternLink}-Methode.

\begin{jcodeblock}
    builder.buildPatternLink(uniPO, "bachelorThreshold", thresholdPO);
    builder.buildPatternLink(uniPO, "uni", "students", studentsPO);
    builder.buildPatternLink(studentsPO, "*", studentAttributesPO);
\end{jcodeblock}

Zu beachten ist in der letzten Zeile der Name ``\code{*}''.
Dieser dient als Platzhalter für den unbekannten Attributsnamen.
Er bewirkt, dass \code{studentAttributesPO} alle Attribute von \code{studentsPO} matcht.
Diese Operation ist in Vorbereitung dieser Arbeit aufbauend auf dem zuvor genutzten \code{expandAll} entstanden.
Wie im vorherigen Beispiel soll dies eingeschränkt werden auf ganze Zahlen unter 1000.
Dafür kommt ein \emph{Attributs-Constraint} zum Einsatz, das wie folgt angelegt wird:

\begin{jcodeblock*}{breaklines}
    builder.buildAttributeConstraint(studentAttributesPO, it -> it instanceof Integer && (Integer) it <= 999);
\end{jcodeblock*}

Kern der Suche ist nun die Bedingung, dass die Credit-Anzahl größer als das von der Uni vorgegebene Minimum für die Bacheloranmeldung ist.
Analog zu \code{filterRows} bei Tables kommt dafür bei Patterns ein \emph{Match-Constraint} zum Einsatz,
das wie folgt deklariert wird:

\begin{jcodeblock}
    builder.buildMatchConstraint(row -> {
        int credits = (int) row.get("StudentAttributes");
        int threshold = (int) row.get("Threshold");
        return credits >= threshold;
    }, studentAttributesPO, thresholdPO);
\end{jcodeblock}

Der Lambda-Ausdruck entspricht hier exakt jenem, der mit \code{filterRows} gebraucht wurde.
Zu beachten ist jedoch hier die Angabe, dass die zu verwendenden Pattern-Objekte dahinter angegeben wurden.
Ohne diese Angabe könnten Match-Constraints immer erst als letzte aufgelöst werden,
was u.U.\ zu sehr großen Zwischenergebnissen führen kann.

Nun sind alle Pattern-Objekte und Constraints angelegt.
Mit \code{builder.getPattern()} lässt sich eine Objekt erhalten, dass all diese kapselt.
Das davon ausgehende Objektdiagramm ist in Abbildung~\ref{fig:pattern-diagram} dargestellt.

\begin{figure}
    % TODO \includegraphics[width=\textwidth]{chapter/pattern-matching/img/pattern-diagram.pdf}
    \caption{Objektdiagramm für das erstellte Pattern}
    \label{fig:pattern-diagram}
\end{figure}

Mit dem Pattern kann nun ein Matching durchgeführt werden.
Dafür wird zunächst ein \code{PatternMatcher} benötigt, der auch direkt aus dem \code{builder} angelegt werden kann.
Dem Matcher werden dann ein oder mehr \emph{Root-Objekte} und \emph{Root-Pattern-Objekte} zugewiesen.
Diese entsprechen den Objekten und Pattern-Objekten, bei denen die Suche begonnen wird.
Ferner werden daraus die Zeilen und Spalten der Tabelle, die intern als Datenstruktur dient.

\begin{jcodeblock}
    PatternMatcher matcher = builder.matcher();
    matcher.withRootPatternObjects(uniPO);
    matcher.withRootObjects(uniKassel);
\end{jcodeblock}

Die Methode \code{match()} führt nach Einrichten des Matchers den eigentlichen Match-Vorgang durch.
Daraufhin lassen sich die Ergebnisse anhand der Pattern-Objekte extrahieren:

\begin{jcodeblock}
    matcher.match();

    List<Student> bachelorReady = matcher.findAll(studentsPO);
    // = [Alice, Charlie]
\end{jcodeblock}

\todo{
Interne Tabellen beim Pattern Matching,
}

\section{Pattern Matching in der Scenario-Sprache}\label{sec:scenario-pattern-matching}

\todo{
We match,
Expectations,
Parallelen OCL/QVT,
}
