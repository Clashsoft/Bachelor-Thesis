\section{Hauptseite}\label{sec:main-page}

Die Hauptseite erreicht man, wenn man fulib.org das erste mal öffnet.
Dabei präsentiert sich der sogenannte Vier-Panel-Editor, welcher in Abbildung~\ref{fig:four-pane-editor}.

\begin{figure}
    \includegraphics[width=\textwidth]{chapter/fulib.org/img/four-pane-editor.png}
    \caption{Der Vier-Panel-Editor auf der Hauptseite von fulib.org}
    \label{fig:four-pane-editor}
\end{figure}

Dieser zeigt oben links den Scenario-Editor sowie darüber dessen Toolbar.
Oben rechts gibt es ein Fenster für den generierten Java-Code, das auch die Konsolenausgabe des Compilers enthält.
Darüber zeigt eine Statusleiste, ob das Kompilieren und Ausführen erfolgreich war und wenn nicht, welches Tool fehlgeschlagen ist.
Im unteren Teil werden links das Klassendiagramm und rechts Objektdiagramme dargestellt.

Am unteren Rand der Seite befindet sich stets der Footer.
Dieser enthält Links zur Navigation innerhalb der Seite und zu externen Referenzen.
Außerdem finden sich darunter die Einstellungen für Datenschutz,
Möglichkeiten zum Hinterlassen von Feedback und zum Einsehen von Änderungen,
und die Schaltfläche zum Wechseln in den Nachtmodus.

\subsection{Interaktiver Spielplatz}\label{subsec:interactive-playground}

Die wichtigste Funktion der Hauptseite ist der Scenario-Editor.
Gibt man darin ein Scenario ein und klickt auf ``Compile and Run'' oder wartet einen Moment,
wird daraus Java-Code generiert und dessen Tests mit JUnit ausgeführt.
Das dabei entstehende Klassendiagramm sowie Objektdiagramme werden dann in den entsprechenden Bereichen angezeigt.
Um das sofortige Feedback zu erleichtern, wird das Scenario immer automatisch ausgeführt, wenn es länger als eine Sekunde unverändert blieb.
Somit muss man nicht manuell auf ``Compile and Run'' klicken.
Alternativ kann die automatische Ausführung im Dropdown neben dem ``Compile and Run''-Button deaktiviert werden.
Händisch lässt es sich dann immernoch durch Klick oder Verwenden der Testenkürzel auslösen.

Im Fenster für den Java-Code werden die Rümpfe sämtlicher Methoden angezeigt, die im Scenario verwendet wurden.
Davon ausgenommen sind aufgrund ihrer Trivialität Getter und Setter sowie diverse standardmäßig generierte Methoden.
Die Ausgabe des Scenario- und Java-Compilers sowie der JUnit-Testausführung werden ebenfalls in diesem Fenster angezeigt.
Dabei sind die Meldungen des Scenario-Compilers besonders relevant, da diese auf Fehler im Scenario hinweisen.

Objektdiagramme werden unter Tabs angeordnet.
Dies vermeidet Unübersichtlichkeit bei der Verwendung von vielen Diagram-Sätzen im Scenario.
Die einzelnen Darstellungen lassen sich dann getrennt voneinander betrachten.

\subsection{Tutorials}\label{subsec:tutorials}

Über dem Scenario-Editor befindet sich ein Auswahlfeld für vordefinierte Tutorials.
Wählt man eines davon aus, wird dessen Scenario-Text in den Editor übernommen und sofort ausgeführt.
Die Tutorials sind in Kategorien angeordnet und haben bauen in ihrer Reihenfolge aufeinander auf.
Somit werden die behandelten Sprachkonzepte zunehmend komplexer.

In den Tutorial-Scenarios ist beschreibender Text mit \code{//}-Kommentaren realisiert.
Diese bewirt, dass der Text auch im Java-Code auftaucht, was die Zuordnung vereinfacht.
Durch Abschnitte erfolgt eine visuelle Trennung von unabhängigen Teil-Scenarios.

Am Ende jedes Tutorials gibt es Links zu entsprechenden Abschnitten in der Dokumentation,
die detaillierte Informationen zu den verwendeten Sprachkonzepten enthalten.
Dazu gehören auch Grammatiken und häufige Problemfälle.

Die von Tutorials stammenden Scenarios können frei verändert werden.
Dadurch können die Sprachkonzepte direkt ausprobiert werden.
Lädt man das entsprechende Tutorial erneut, wird das vordefinierte Scenario verwendet und die Änderungen verworfen.

\subsection{Projektstarter}\label{subsec:project-starter}

Neben dem ``Compile and Run''-Button befindet sich der Button ``Configure Project''.
Damit lässt sich das Fenster zur Projektkonfiguration öffnen, welches in Abbildung~\ref{fig:project-config} zu sehen ist.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{chapter/fulib.org/img/project-config.png}
    \caption{Projektkonfiguration}
    \label{fig:project-config}
\end{figure}

In diesem werden Einstellungen zum Projekt durchgeführt, zu dem das Scenario später gehören soll.
Genauer lassen sich dessen Name und Version sowie Paket und Dateiname des Scenarios einstellen.
Diese werden wie der Scenario-Text im Browser gespeichert, damit sie beim erneuten Aufrufen der Seite bestehen bleiben.
Eingestellte Werte haben nur geringen Einfluss auf die Funktionalität der Webseite selbst;
jedoch sind sie beim Herunterladen eines Projekts von Relevanz.
Dies ist mit einem Button im unteren Teil des Fensters möglich.
Klickt man auf diesen, wird das Scenario zusammen mit einigen Konfigurations-Dateien in einem Zip-Archiv verpackt und auf die Festplatte heruntergeladen.
Bei den Konfigurationsdateien handelt es sich um jene, die das Build-Tool Gradle~\cite{gradle} benötigt.
Dieses ist zuständig für Kompilierung, Dependency-Management, Test-Ausführung und andere Build-Aufgaben in Java-Projekten.
Das Projekt ist voreingestellt, um den Scenario-Compiler in den Build-Prozess zu integrieren.

Entpackt man das heruntergeladene Archiv, erhält man einen fertigen Projektordner.
Dieser kann in einer IDE mit Gradle-Unterstützung wie z.B.\ IntelliJ geöffnet werden.
Führt man daraufhin den \code{check}-Task mit Gradle aus (Kommandozeile: \code{./gradlew check} im Projektordner),
wird das zuvor auf fulib.org geschriebene Scenario kompiliert und generierte Java-Dateien in den entsprechenden Ordnern unter \code{src/} abgelegt.
Außerdem werden generierte Tests sofort ausgeführt.
Ändert man die Scenario-Datei und führt den Task erneut aus, wird auch der Java-Code angepasst.

Der Projektexport ist vor allem dann relevant, wenn das Scenario zu groß wird, um im Editor auf fulib.org übersichtlich zu sein.
Dies ist meist ein Anzeichen dafür, dass man ein richtiges Projekt beginnen sollte.
Zudem können dann mehrere Scenario-Dateien angelegt werden.
Ein weitere Vorteil ist, dass der generierte Java-Code vollständig einsehbar und anpassbar ist.
Dabei bietet es sich an, das Projekt unter Versionskontrolle wie Git zu stellen.
Im Projektarchiv enthalten ist eine voreingestellte \code{.gitignore}-Datei, um das Einrichten zu erleichtern.

\subsection{Sicht der Studenten}\label{subsec:students-view}

\todo{
Feedback-Funktion.
Allgemeine Bewertung (PM).
Wünsche.
}

\subsection{Datensammlung}\label{subsec:data-collection}

Öffnet man fulib.org das erste Mal, erscheint das Fenster mit den Datenschutz-Einstellungen, das in Abbildung~\ref{fig:privacy} gezeigt ist.
Darin kann ausgewählt werden, ob man lokale (d.h. im Browser) oder serverseitige Datenspeicherung erlauben möchte.

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{chapter/fulib.org/img/privacy.png}
    \caption{Projektkonfiguration}
    \label{fig:privacy}
\end{figure}

Zu lokale Daten zählen auf der Hauptseite der Scenario-Text sowie die Projekteinstellungen.
Erlaubt man die lokale Speicherung nicht, werden diese nach erneutem Laden des Seite auf Standardwerte zurückgesetzt.
Außerdem wird die Auswahl der Datenschutzeinstellung selbst lokal gespeichert.
Ist dies nicht erlaubt, öffnet sich das Einstellungsfenster bei jedem Öffnen von fulib.org automatisch.
Für datenschutzbewusste Benutzer, die dies als Störung empfinden, gibt es daher die vierte Option,
welche die lokale Datenspeicherung lediglich zum Verstecken des Fensters nutzt.

Die serverseitige Datenspeicherung umfasst sämtliche ``Compile and Run''-Anfragen, die an den Server gestellt werden, inklusive automatische.
Der Server speichert dann die vollständige Anfrage (d.h. Scenario-Text und Projektkonfiguration) und die vollständige API-Antwort.
Letztere enthält Compiler-Ausgabe, Methodenrümpfe und Diagramme.
Weiterhin werden IP-Adresse und User-Agent der Anfrage protokolliert, was die progressive Anordnung der Anfragen erlaubt.
Dies erlaubt beispielsweise die Analyse von dem Zeitaufwand, der für das Lesen und Verstehen der Beispielscenarios benötigt wird.

Während der Vorlesung Programmieren und Modellieren im Wintersemester 2019/20 konnte serverseitig eine Vielzahl von Daten gesammelt werden.
Zum Zeitpunkt dem Messung am 16.\ Februar 2020, 18:00, wurden seit 1.\ Oktober 2019 etwa 5100 Anfragen gespeichert.
Aufgrund der änderbaren Natur von IP-Adressen und User-Agent-Zeichenketten kann nicht auf die Anzahl der unterschiedlichen Benutzer geschlossen werden.
Außerdem ist nicht bekannt, wie viele Nutzer die serverseitigen Datenspeicherung abgelehnt haben.
Dennoch haben die gesammelten Daten bereits hohen Wert gezeigt.
Da die Fehlermeldung des Scenario-Compilers IDs wie \code{[variable.redeclaration]} enthalten, kann leicht danach in dem Datensatz gesucht werden.

Von den oben genannten Anfragen enthielten 847 mindestens eine Fehler- oder Warnmeldung.
Insgesamt belief sich die Zahl der gefundenen Meldungen auf 1949.
Tabelle~\ref{tab:error-counts} stellt diese dar.

\begin{table}
    \caption{Zusammengefasste Anzahl der Fehlermeldungen nach ID}
    \label{tab:error-counts}
    \centering
    \begin{tabular}{rl}
        \toprule
        21	& \code{[remove.source.type]} \\
        29	& \code{[property.unresolved]} \\
        33	& \code{[write.target.list]} \\
        34	& \code{[association.reverse.conflict]} \\
        39	& \code{[descriptor.multi.indefinite.deprecated]} (Warnung) \\
        65	& \code{[add.target.type]} \\
        86	& \code{[attribute.reverse.name]} \\
        177	& \code{[descriptor.indefinite.deprecated]} (Warnung) \\
        254	& \code{[property.redeclaration.conflict]} \\
        283	& \code{[has.subject.primitive]} \\
        288	& \code{[property.declaration.first]} (Hinweis) \\
        298	& \code{[variable.redeclaration]} \\
        298	& \code{[variable.declaration.first]} (Hinweis) \\
        44  & sonstige Fehler \\
        \midrule
        1949 & Gesamt (inkl.\ Hinweise) \\
        1363 & Fehler- und Warnmeldungen \\
        1147 & Fehlermeldungen \\
        \bottomrule
    \end{tabular}
\end{table}

Zu den häufigsten Meldungen zählen hier \code{[property.declaration.first]} und \code{[variable.declaration.first]}.
Dabei handelt es sich weder um Fehler noch um Warnung;
diese Meldungen sind Hinweise und treten in Kombination mit den Fehlern \code{[association.reverse.conflict]} und \code{[property.redeclaration.conflict]} bzw. \code{[variable.redeclaration]} auf.
Die Hinweise dienen dazu, diese leichter zu lösen, da sie auf vorherige Stellen im Scenario verweisen.
Warnmeldungen sind hier ausschließlich Deprecations, welche bei Verwendungen von Syntax auftreten, die in Zukunft nicht mehr unterstützt werden soll.

Die Statistik, welche Fehler am meisten auftreten, hatte besonderen Wert bei der Verbesserung der Fehlermeldungen.
So konnte priorisiert werden, welche Änderungen die größte Wirkung erzielen.
Im Verlauf dieser Arbeit ist eine Hinweismeldung hinzugekommen, welche auf eventuelle Tippfehler bei Werten und Attribut- und Assoziationsnamen verweist.
Diese findet bei zehn in der Tabelle gezeigten Fehlern Anwendung (vier davon unter ``sonstige''),
welche insgesamt 775 Mal aufgetreten sind.
Dies entspricht einer Verbesserung von etwa zwei dritteln aller Fehlermeldungen.
